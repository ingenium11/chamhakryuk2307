[1] ---------------------------------------------
from keras.datasets import mnist

(x_train, y_train), (x_test, y_test) = mnist.load_data()
print("x_train shape", x_train.shape)
print("y_train shape", y_train.shape)
print("x_test shape", x_test.shape)
print("y_test shape", x_test.shape)

[2] ---------------------------------------------
import matplotlib.pyplot as plt

# 아래 숫자는 0~59,999 사이의 임의 값 입력
idx = 59952

plt.figure(figsize=(4,4))
plt.subplot(1, 2, 1)
plt.title('Original')
plt.imshow(x_train[idx])
plt.subplot(1, 2, 2)
plt.title('Black&White')
plt.imshow(x_train[idx], cmap='gray_r')
plt.tight_layout()
plt.show()
print(f"위 사진의 값은 {y_train[idx]} 으로 입력되어 있습니다.")

[3] ---------------------------------------------
pdata = x_train[idx].reshape(1, 28*28)

for index, pixel in enumerate(pdata[0]) :
  if index % 28 == 0:
    print("\n")
  else :
    print("%4d"%pixel, end="")
print('\n')

[4] ---------------------------------------------
#x_train = x_train.reshape(x_train.shape[0], 784).astype('float32') / 255
#x_test = x_test.reshape(x_test.shape[0], 784).astype('float32') / 255

X_train = x_train.reshape(x_train.shape[0], 28,28,1)
X_train= X_train.astype('float32')
X_train /= 255

X_test = x_test.reshape(x_test.shape[0], 28,28,1)
X_test= X_test.astype('float32')
X_test /= 255

print("X Training matrix shape", X_train.shape )
print("X Testing matrix shape", X_test.shape )

[5] ---------------------------------------------
from keras.utils import to_categorical

Y_train = to_categorical(y_train, 10)
Y_test = to_categorical(y_test, 10)

print("Y Training matrix shape", Y_train.shape )
print("Y Testing matrix shape", Y_test.shape )

[6] ---------------------------------------------
from keras.models import Sequential
from keras.layers import Dense, Activation, Conv2D, MaxPooling2D, Flatten # Conv2D, MaxPooling2D, Flatten 추가

model = Sequential()
model.add(Conv2D(6,(5,5), padding='same', activation='relu', input_shape=(28,28,1)))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Conv2D(16,(5,5), padding='same', activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Conv2D(120,(5,5), padding='same', activation='relu'))
model.add(Flatten())
model.add(Dense(84, activation='relu'))
model.add(Dense(10, activation='softmax'))
model.summary()

[7] ---------------------------------------------
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=["accuracy"])
hist = model.fit(X_train, Y_train, epochs=5, batch_size=128, validation_data=(X_test, Y_test), verbose=1)

[8] ---------------------------------------------
model.save('mnist_LeNet5_Model_epoch5.h5')

[9] ---------------------------------------------
score = model.evaluate(X_test, Y_test)
print("Test score: ", score[0])
print("Test accuracy: ", score[1])

[10] ---------------------------------------------
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.plot(hist.history['accuracy'])
plt.plot(hist.history['val_accuracy'])
plt.title('Model accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'],loc='best')
plt.grid()

plt.subplot(1, 2, 2)
plt.plot(hist.history['loss'])
plt.plot(hist.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'],loc='best')
plt.grid()

plt.tight_layout()
plt.show()

[11] ---------------------------------------------
#model = load_model('mnist_LeNet5_Model_epoch15.h5')

[12] ---------------------------------------------
import numpy as np

predicted_classes = np.argmax(model.predict(X_test), axis=1)
correct_indices = np.nonzero(predicted_classes == y_test)[0]
incorrect_indices = np.nonzero(predicted_classes != y_test)[0]

[13] ---------------------------------------------
print(f"1000개의 손글씨 숫자 중 {len(correct_indices)} 개를 맞췄고,")
print(f"                        {len(incorrect_indices)} 개는 못 맞췄습니다.")

[14] ---------------------------------------------
plt.figure()
for i in range(9):
  plt.subplot(3, 3, i+1)
  correct = correct_indices[i]
  plt.imshow(X_test[correct].reshape(28,28), cmap='gray')
  plt.title("Predicted {}, Class {}".format(predicted_classes[correct], y_test[correct]))
plt.tight_layout()

[15] ---------------------------------------------
plt.figure()
for i in range(9):
  plt.subplot(3, 3, i+1)
  incorrect = incorrect_indices[i]
  plt.imshow(X_test[incorrect].reshape(28,28), cmap='gray')
  plt.title("Predicted {}, Class {}".format(predicted_classes[incorrect], y_test[incorrect]))
plt.tight_layout()

[16] ---------------------------------------------
#from keras.models import load_model

# 이미지 처리 위해 필요한 라이브러리 호출
from PIL import Image

# 손글씨*.png는 그림판에서 붓으로 숫자 그린 이미지 파일
# 손글씨*.png 파일 열어서 L(256단계 흑백이미지)로 변환
# 아래 코드에서 '홍길동손글씨5' 대신 본인이 만든 이미지 파일 이름으로 수정
img = Image.open("홍길동손글씨5.png").convert("L")

# 이미지 출력
plt.figure(figsize=(1,1))
plt.imshow(img, cmap='gray')
plt.show()

# 이미지를 784개 흑백 픽셀로 사이즈 변환
img = np.resize(img, (1, 28,28,1))

# 데이터를 모델에 적용할 수 있도록 가공
test_data = ((np.array(img) / 255) - 1) * -1

# 모델 불러오기
#model = load_model('mnist_LeNet5_Model_epoch15.h5')

# 클래스 예측 함수에 가공된 테스트 데이터 넣어 결과 도출
res =(model.predict(test_data) > 0.5).astype("int32")
print(res)

res = np.where(res[0] == 1)
print(res[0])

if len(res[0]) :    # 예측한 값이 있으면 (없으면 빈 리스트를 반환하므로)
  print("예측한 값은", res[0][0])
else :
  print("뭐라고 썼는지 잘 모르겠어요")
